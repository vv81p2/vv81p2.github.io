<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Redis的数据回写机制与持久化 | vv81p2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Redis的数据回写机制Redis的数据回写机制分同步和异步两种:  同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的。  异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死，一般默认会采用这个方法。   个人感觉方法２采用fork主进程的方">
<meta property="og:type" content="website">
<meta property="og:title" content="Redis的数据回写机制与持久化">
<meta property="og:url" content="http://sukora.cn/testsec/index.html">
<meta property="og:site_name" content="vv81p2">
<meta property="og:description" content="Redis的数据回写机制Redis的数据回写机制分同步和异步两种:  同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的。  异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死，一般默认会采用这个方法。   个人感觉方法２采用fork主进程的方">
<meta property="og:updated_time" content="2017-10-07T11:41:41.240Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis的数据回写机制与持久化">
<meta name="twitter:description" content="Redis的数据回写机制Redis的数据回写机制分同步和异步两种:  同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的。  异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死，一般默认会采用这个方法。   个人感觉方法２采用fork主进程的方">
  
    <link rel="alternate" href="/atom.xml" title="vv81p2" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">vv81p2</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sukora.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/testsec/index.html" class="article-date">
  <time datetime="2017-10-07T11:26:32.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis的数据回写机制与持久化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis的数据回写机制"><a href="#Redis的数据回写机制" class="headerlink" title="Redis的数据回写机制"></a>Redis的数据回写机制</h1><p>Redis的数据回写机制分同步和异步两种:</p>
<ol>
<li><p>同步回写即SAVE命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的。</p>
</li>
<li><p>异步回写即BGSAVE命令，主进程fork后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死，一般默认会采用这个方法。</p>
</li>
</ol>
<p>个人感觉方法２采用fork主进程的方式很拙劣，但似乎是唯一的方法。内存中的热数据随时可能修改，要在磁盘上保存某个时间的内存镜像必须要冻结。冻结就会导致假死。fork一个新的进程之后等于复制了当时的一个内存镜像，这样主进程上就不需要冻结，只要子进程上操作就可以了。</p>
<p>在小内存的进程上做一个fork,不需要太多资源，但当这个进程的内存空间以Ｇ为单位时，fork就成为一件很恐怖的操作。何况在16G内存的主机上fork 14G内存的进程呢？肯定会报内存无法分配的。更可气的是，越是改动频繁的主机上fork也越频繁，fork操作本身的代价恐怕也不会比假死好多少。</p>
<p>找到原因之后，直接修改/etc/sysctl.conf内核参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm.overcommit_memory= 1</div><div class="line">sysctl -p</div></pre></td></tr></table></figure>
<p>Linux内核会根据参数vm.overcommit_memory参数的设置决定是否放行。</p>
<p>如果<br><figure class="highlight plain"><figcaption><span>= 1```：直接放行；</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">```vm.overcommit_memory = 0```：则比较此次请求分配的虚拟内存大小和系统当前空闲的物理内存加上swap，决定是否放行。</div><div class="line">```vm.overcommit_memory= 2```：则会比较进程所有已分配的虚拟内存加上此次请求分配的虚拟内存和系统当前的空闲物理内存加上swap，决定是否放行。</div><div class="line"></div><div class="line">## Redis持久化实践及灾难恢复模拟</div><div class="line"></div><div class="line">参考资料：</div><div class="line">Redis Persistence http://redis.io/topics/persistence</div><div class="line">Google Groups https://groups.google.com/forum/?fromgroups=#!forum/redis-db</div><div class="line"></div><div class="line"># 对Redis持久化的探讨与理解</div><div class="line"></div><div class="line">目前Redis持久化的方式有两种： RDB 和 AOF</div><div class="line"></div><div class="line">首先，我们应该明确持久化的数据有什么用，答案是用于重启后的数据恢复。</div><div class="line">Redis是一个内存数据库，无论是RDB还是AOF，都只是其保证数据恢复的措施。</div><div class="line">所以Redis在利用RDB和AOF进行恢复的时候，都会读取RDB或AOF文件，重新加载到内存中。</div><div class="line"></div><div class="line">RDB就是Snapshot快照存储，是默认的持久化方式。</div><div class="line">可理解为半持久化模式，即按照一定的策略周期性的将数据保存到磁盘。</div><div class="line">对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。</div><div class="line">下面是默认的快照设置：</div><div class="line">``` shell</div><div class="line">save 900 1    #当有一条Keys数据被改变时，900秒刷新到Disk一次</div><div class="line">save 300 10   #当有10条Keys数据被改变时，300秒刷新到Disk一次</div><div class="line">save 60 10000 #当有10000条Keys数据被改变时，60秒刷新到Disk一次</div></pre></td></tr></table></figure></p>
<p>Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的。<br>当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件。<br>这样在任何时候出现故障，Redis的RDB文件都总是可用的。</p>
<p>同时，Redis的RDB文件也是Redis主从同步内部实现中的一环。<br>第一次Slave向Master同步的实现是：<br>Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。<br>第二次以及以后的同步实现是：<br>Master将变量的快照直接实时依次发送给各个Slave。<br>但不管什么原因导致Slave和Master断开重连都会重复以上两个步骤的过程。<br>Redis的主从复制是建立在内存快照的持久化基础上的，只要有Slave就一定会有内存快照发生。</p>
<p>可以很明显的看到，RDB有它的不足，就是一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的。<br>从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。</p>
<p>AOF(Append-Only File)比RDB方式有更好的持久化性。<br>由于在使用AOF持久化方式时，Redis会将每一个收到的写命令都通过Write函数追加到文件中，类似于MySQL的binlog。<br>当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。<br>对应的设置参数为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> vim /opt/redis/etc/redis_6379.conf</div><div class="line"></div><div class="line">appendonly yes       #启用AOF持久化方式</div><div class="line">appendfilename appendonly.aof #AOF文件的名称，默认为appendonly.aof</div><div class="line"><span class="meta">#</span> appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</div><div class="line">appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</div><div class="line"><span class="meta">#</span> appendfsync no     #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</div></pre></td></tr></table></figure>
<p>AOF的完全持久化方式同时也带来了另一个问题，持久化文件会变得越来越大。<br>比如我们调用INCR test命令100次，文件中就必须保存全部的100条命令，但其实99条都是多余的。<br>因为要恢复数据库的状态其实文件中保存一条SET test 100就够了。<br>为了压缩AOF的持久化文件，Redis提供了bgrewriteaof命令。<br>收到此命令后Redis将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件，以此来实现控制AOF文件的增长。<br>由于是模拟快照的过程，因此在重写AOF文件时并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件。<br>对应的设置参数为:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> vim /opt/redis/etc/redis_6379.conf</div><div class="line"></div><div class="line">no-appendfsync-on-rewrite yes   #在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。</div><div class="line">auto-aof-rewrite-percentage 100 #当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</div><div class="line">auto-aof-rewrite-min-size 64mb  #当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</div></pre></td></tr></table></figure></p>
<p>到底选择什么呢？下面是来自官方的建议：<br>通常，如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。<br>如果你可以接受灾难带来的几分钟的数据丢失，那么你可以仅使用RDB。<br>很多用户仅使用了AOF，但是我们建议，既然RDB可以时不时的给数据做个完整的快照，并且提供更快的重启，所以最好还是也使用RDB。<br>因此，我们希望可以在未来（长远计划）统一AOF和RDB成一种持久化模式。</p>
<p>在数据恢复方面：<br>RDB的启动时间会更短，原因有两个：<br>一是RDB文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了。<br>另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。</p>
<p>二、灾难恢复模拟<br>既然持久化的数据的作用是用于重启后的数据恢复，那么我们就非常有必要进行一次这样的灾难恢复模拟了。<br>据称如果数据要做持久化又想保证稳定性，则建议留空一半的物理内存。因为在进行快照的时候，fork出来进行dump操作的子进程会占用与父进程一样的内存，真正的copy-on-write，对性能的影响和内存的耗用都是比较大的。<br>目前，通常的设计思路是利用Replication机制来弥补aof、snapshot性能上的不足，达到了数据可持久化。<br>即Master上Snapshot和AOF都不做，来保证Master的读写性能，而Slave上则同时开启Snapshot和AOF来进行持久化，保证数据的安全性。</p>
<p>首先，修改Master上的如下配置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> sudo vim /opt/redis/etc/redis_6379.conf</div><div class="line"></div><div class="line"><span class="meta">#</span>save 900 1 #禁用Snapshot</div><div class="line"><span class="meta">#</span>save 300 10</div><div class="line"><span class="meta">#</span>save 60 10000</div><div class="line"></div><div class="line">appendonly no #禁用AOF</div><div class="line">接着，修改Slave上的如下配置：</div><div class="line"><span class="meta">$</span> sudo vim /opt/redis/etc/redis_6379.conf</div><div class="line"></div><div class="line">save 900 1 #启用Snapshot</div><div class="line">save 300 10</div><div class="line">save 60 10000</div><div class="line"></div><div class="line">appendonly yes #启用AOF</div><div class="line">appendfilename appendonly.aof #AOF文件的名称</div><div class="line"><span class="meta">#</span> appendfsync always</div><div class="line">appendfsync everysec #每秒钟强制写入磁盘一次</div><div class="line"><span class="meta">#</span> appendfsync no  </div><div class="line"></div><div class="line">no-appendfsync-on-rewrite yes   #在日志重写时，不进行命令追加操作</div><div class="line">auto-aof-rewrite-percentage 100 #自动启动新的日志重写过程</div><div class="line">auto-aof-rewrite-min-size 64mb  #启动新的日志重写过程的最小值</div></pre></td></tr></table></figure></p>
<p>分别启动Master与Slave<br><figure class="highlight plain"><figcaption><span>/etc/init.d/redis start```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">启动完成后在Master中确认未启动Snapshot参数</div><div class="line">``` shell</div><div class="line">redis 127.0.0.1:6379&gt; CONFIG GET save</div><div class="line">1) &quot;save&quot;</div><div class="line">2) &quot;&quot;</div></pre></td></tr></table></figure></p>
<p>然后通过以下脚本在Master中生成25万条数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@redis:/opt/redis/data/6379$ cat redis-cli-generate.temp.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">REDISCLI="redis-cli -a slavepass -n 1 SET"</div><div class="line">ID=1</div><div class="line"></div><div class="line"><span class="meta">while(($</span>ID&lt;50001))</div><div class="line">do</div><div class="line">  INSTANCE_NAME="i-2-$ID-VM"</div><div class="line">  UUID=`cat /proc/sys/kernel/random/uuid`</div><div class="line">  PRIVATE_IP_ADDRESS=10.`echo "$RANDOM % 255 + 1" | bc`.`echo "$RANDOM % 255 + 1" | bc`.`echo "$RANDOM % 255 + 1" | bc`\</div><div class="line">  CREATED=`date "+%Y-%m-%d %H:%M:%S"`</div><div class="line"></div><div class="line"><span class="meta">  $</span>REDISCLI vm_instance:$ID:instance_name "$INSTANCE_NAME"</div><div class="line"><span class="meta">  $</span>REDISCLI vm_instance:$ID:uuid "$UUID"</div><div class="line"><span class="meta">  $</span>REDISCLI vm_instance:$ID:private_ip_address "$PRIVATE_IP_ADDRESS"</div><div class="line"><span class="meta">  $</span>REDISCLI vm_instance:$ID:created "$CREATED"</div><div class="line"></div><div class="line"><span class="meta">  $</span>REDISCLI vm_instance:$INSTANCE_NAME:id "$ID"</div><div class="line"></div><div class="line">  ID=$(($ID+1))</div><div class="line">done</div><div class="line">dongguo@redis:/opt/redis/data/6379$ ./redis-cli-generate.temp.sh</div></pre></td></tr></table></figure>
<p>在数据的生成过程中，可以很清楚的看到Master上仅在第一次做Slave同步时创建了dump.rdb文件，之后就通过增量传输命令的方式给Slave了。<br>dump.rdb文件没有再增大。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dongguo@redis:/opt/redis/data/6379$ ls -lh</div><div class="line">total 4.0K</div><div class="line">-rw-r--r-- 1 root root 10 Sep 27 00:40 dump.rdb</div></pre></td></tr></table></figure>
<p>而Slave上则可以看到dump.rdb文件和AOF文件在不断的增大，并且AOF文件的增长速度明显大于dump.rdb文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dongguo@redis-slave:/opt/redis/data/6379$ ls -lh</div><div class="line">total 24M</div><div class="line">-rw-r--r-- 1 root root 15M Sep 27 12:06 appendonly.aof</div><div class="line">-rw-r--r-- 1 root root 9.2M Sep 27 12:06 dump.rdb</div></pre></td></tr></table></figure>
<p>等待数据插入完成以后，首先确认当前的数据量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; info</div><div class="line"></div><div class="line">redis_version:2.4.17</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">arch_bits:64</div><div class="line">multiplexing_api:epoll</div><div class="line">gcc_version:4.4.5</div><div class="line">process_id:27623</div><div class="line">run_id:e00757f7b2d6885fa9811540df9dfed39430b642</div><div class="line">uptime_in_seconds:1541</div><div class="line">uptime_in_days:0</div><div class="line">lru_clock:650187</div><div class="line">used_cpu_sys:69.28</div><div class="line">used_cpu_user:7.67</div><div class="line">used_cpu_sys_children:0.00</div><div class="line">used_cpu_user_children:0.00</div><div class="line">connected_clients:1</div><div class="line">connected_slaves:1</div><div class="line">client_longest_output_list:0</div><div class="line">client_biggest_input_buf:0</div><div class="line">blocked_clients:0</div><div class="line">used_memory:33055824</div><div class="line">used_memory_human:31.52M</div><div class="line">used_memory_rss:34717696</div><div class="line">used_memory_peak:33055800</div><div class="line">used_memory_peak_human:31.52M</div><div class="line">mem_fragmentation_ratio:1.05</div><div class="line">mem_allocator:jemalloc-3.0.0</div><div class="line">loading:0</div><div class="line">aof_enabled:0</div><div class="line">changes_since_last_save:250000</div><div class="line">bgsave_in_progress:0</div><div class="line">last_save_time:1348677645</div><div class="line">bgrewriteaof_in_progress:0</div><div class="line">total_connections_received:250007</div><div class="line">total_commands_processed:750019</div><div class="line">expired_keys:0</div><div class="line">evicted_keys:0</div><div class="line">keyspace_hits:0</div><div class="line">keyspace_misses:0</div><div class="line">pubsub_channels:0</div><div class="line">pubsub_patterns:0</div><div class="line">latest_fork_usec:246</div><div class="line">vm_enabled:0</div><div class="line">role:master</div><div class="line">slave0:10.6.1.144,6379,online</div><div class="line">db1:keys=250000,expires=0</div></pre></td></tr></table></figure>
<p>当前的数据量为25万条key，占用内存31.52M。</p>
<p>然后我们直接Kill掉Master的Redis进程，模拟灾难。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dongguo@redis:/opt/redis/data/6379$ sudo killall -9 redis-server</div></pre></td></tr></table></figure>
<p>我们到Slave中查看状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; info</div><div class="line"></div><div class="line">redis_version:2.4.17</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">arch_bits:64</div><div class="line">multiplexing_api:epoll</div><div class="line">gcc_version:4.4.5</div><div class="line">process_id:13003</div><div class="line">run_id:9b8b398fc63a26d160bf58df90cf437acce1d364</div><div class="line">uptime_in_seconds:1627</div><div class="line">uptime_in_days:0</div><div class="line">lru_clock:654181</div><div class="line">used_cpu_sys:29.69</div><div class="line">used_cpu_user:1.21</div><div class="line">used_cpu_sys_children:1.70</div><div class="line">used_cpu_user_children:1.23</div><div class="line">connected_clients:1</div><div class="line">connected_slaves:0</div><div class="line">client_longest_output_list:0</div><div class="line">client_biggest_input_buf:0</div><div class="line">blocked_clients:0</div><div class="line">used_memory:33047696</div><div class="line">used_memory_human:31.52M</div><div class="line">used_memory_rss:34775040</div><div class="line">used_memory_peak:33064400</div><div class="line">used_memory_peak_human:31.53M</div><div class="line">mem_fragmentation_ratio:1.05</div><div class="line">mem_allocator:jemalloc-3.0.0</div><div class="line">loading:0</div><div class="line">aof_enabled:1</div><div class="line">changes_since_last_save:3308</div><div class="line">bgsave_in_progress:0</div><div class="line">last_save_time:1348718951</div><div class="line">bgrewriteaof_in_progress:0</div><div class="line">total_connections_received:4</div><div class="line">total_commands_processed:250308</div><div class="line">expired_keys:0</div><div class="line">evicted_keys:0</div><div class="line">keyspace_hits:0</div><div class="line">keyspace_misses:0</div><div class="line">pubsub_channels:0</div><div class="line">pubsub_patterns:0</div><div class="line">latest_fork_usec:694</div><div class="line">vm_enabled:0</div><div class="line">role:slave</div><div class="line">aof_current_size:17908619</div><div class="line">aof_base_size:16787337</div><div class="line">aof_pending_rewrite:0</div><div class="line">aof_buffer_length:0</div><div class="line">aof_pending_bio_fsync:0</div><div class="line">master_host:10.6.1.143</div><div class="line">master_port:6379</div><div class="line">master_link_status:down</div><div class="line">master_last_io_seconds_ago:-1</div><div class="line">master_sync_in_progress:0</div><div class="line">master_link_down_since_seconds:25</div><div class="line">slave_priority:100</div><div class="line">db1:keys=250000,expires=0</div></pre></td></tr></table></figure>
<p>可以看到master_link_status的状态已经是down了，Master已经不可访问了。<br>而此时，Slave依然运行良好，并且保留有AOF与RDB文件。</p>
<p>下面我们将通过Slave上保存好的AOF与RDB文件来恢复Master上的数据。</p>
<p>首先，将Slave上的同步状态取消，避免主库在未完成数据恢复前就重启，进而直接覆盖掉从库上的数据，导致所有的数据丢失。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; SLAVEOF NO ONE</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>确认一下已经没有了master相关的配置信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; INFO</div><div class="line"></div><div class="line">redis_version:2.4.17</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">arch_bits:64</div><div class="line">multiplexing_api:epoll</div><div class="line">gcc_version:4.4.5</div><div class="line">process_id:13003</div><div class="line">run_id:9b8b398fc63a26d160bf58df90cf437acce1d364</div><div class="line">uptime_in_seconds:1961</div><div class="line">uptime_in_days:0</div><div class="line">lru_clock:654215</div><div class="line">used_cpu_sys:29.98</div><div class="line">used_cpu_user:1.22</div><div class="line">used_cpu_sys_children:1.76</div><div class="line">used_cpu_user_children:1.42</div><div class="line">connected_clients:1</div><div class="line">connected_slaves:0</div><div class="line">client_longest_output_list:0</div><div class="line">client_biggest_input_buf:0</div><div class="line">blocked_clients:0</div><div class="line">used_memory:33047696</div><div class="line">used_memory_human:31.52M</div><div class="line">used_memory_rss:34779136</div><div class="line">used_memory_peak:33064400</div><div class="line">used_memory_peak_human:31.53M</div><div class="line">mem_fragmentation_ratio:1.05</div><div class="line">mem_allocator:jemalloc-3.0.0</div><div class="line">loading:0</div><div class="line">aof_enabled:1</div><div class="line">changes_since_last_save:0</div><div class="line">bgsave_in_progress:0</div><div class="line">last_save_time:1348719252</div><div class="line">bgrewriteaof_in_progress:0</div><div class="line">total_connections_received:4</div><div class="line">total_commands_processed:250311</div><div class="line">expired_keys:0</div><div class="line">evicted_keys:0</div><div class="line">keyspace_hits:0</div><div class="line">keyspace_misses:0</div><div class="line">pubsub_channels:0</div><div class="line">pubsub_patterns:0</div><div class="line">latest_fork_usec:1119</div><div class="line">vm_enabled:0</div><div class="line">role:master</div><div class="line">aof_current_size:17908619</div><div class="line">aof_base_size:16787337</div><div class="line">aof_pending_rewrite:0</div><div class="line">aof_buffer_length:0</div><div class="line">aof_pending_bio_fsync:0</div><div class="line">db1:keys=250000,expires=0</div><div class="line">在Slave上复制数据文件：</div><div class="line">dongguo@redis-slave:/opt/redis/data/6379$ tar cvf /home/dongguo/data.tar *</div><div class="line">appendonly.aof</div><div class="line">dump.rdb</div></pre></td></tr></table></figure>
<p>将data.tar上传到Master上，尝试恢复数据:<br>可以看到Master目录下有一个初始化Slave的数据文件，很小，将其删除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dongguo@redis:/opt/redis/data/6379$ ls -l</div><div class="line">total 4</div><div class="line">-rw-r--r-- 1 root root 10 Sep 27 00:40 dump.rdb</div><div class="line">dongguo@redis:/opt/redis/data/6379$ sudo rm -f dump.rdb</div></pre></td></tr></table></figure>
<p>然后解压缩数据文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dongguo@redis:/opt/redis/data/6379$ sudo tar xf /home/dongguo/data.tar</div><div class="line">dongguo@redis:/opt/redis/data/6379$ ls -lh</div><div class="line">total 29M</div><div class="line">-rw-r--r-- 1 root root 18M Sep 27 01:22 appendonly.aof</div><div class="line">-rw-r--r-- 1 root root 12M Sep 27 01:22 dump.rdb</div></pre></td></tr></table></figure>
<p>启动Master上的Redis；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dongguo@redis:/opt/redis/data/6379$ sudo /etc/init.d/redis start</div><div class="line">Starting Redis server...</div></pre></td></tr></table></figure>
<p>查看数据是否恢复：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; INFO</div><div class="line"></div><div class="line">redis_version:2.4.17</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">arch_bits:64</div><div class="line">multiplexing_api:epoll</div><div class="line">gcc_version:4.4.5</div><div class="line">process_id:16959</div><div class="line">run_id:6e5ba6c053583414e75353b283597ea404494926</div><div class="line">uptime_in_seconds:22</div><div class="line">uptime_in_days:0</div><div class="line">lru_clock:650292</div><div class="line">used_cpu_sys:0.18</div><div class="line">used_cpu_user:0.20</div><div class="line">used_cpu_sys_children:0.00</div><div class="line">used_cpu_user_children:0.00</div><div class="line">connected_clients:1</div><div class="line">connected_slaves:0</div><div class="line">client_longest_output_list:0</div><div class="line">client_biggest_input_buf:0</div><div class="line">blocked_clients:0</div><div class="line">used_memory:33047216</div><div class="line">used_memory_human:31.52M</div><div class="line">used_memory_rss:34623488</div><div class="line">used_memory_peak:33047192</div><div class="line">used_memory_peak_human:31.52M</div><div class="line">mem_fragmentation_ratio:1.05</div><div class="line">mem_allocator:jemalloc-3.0.0</div><div class="line">loading:0</div><div class="line">aof_enabled:0</div><div class="line">changes_since_last_save:0</div><div class="line">bgsave_in_progress:0</div><div class="line">last_save_time:1348680180</div><div class="line">bgrewriteaof_in_progress:0</div><div class="line">total_connections_received:1</div><div class="line">total_commands_processed:1</div><div class="line">expired_keys:0</div><div class="line">evicted_keys:0</div><div class="line">keyspace_hits:0</div><div class="line">keyspace_misses:0</div><div class="line">pubsub_channels:0</div><div class="line">pubsub_patterns:0</div><div class="line">latest_fork_usec:0</div><div class="line">vm_enabled:0</div><div class="line">role:master</div><div class="line">db1:keys=250000,expires=0</div></pre></td></tr></table></figure>
<p>可以看到25万条数据已经完整恢复到了Master上。</p>
<p>此时，可以放心的恢复Slave的同步设置了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; SLAVEOF 10.6.1.143 6379</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>查看同步状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; INFO</div><div class="line"></div><div class="line">redis_version:2.4.17</div><div class="line">redis_git_sha1:00000000</div><div class="line">redis_git_dirty:0</div><div class="line">arch_bits:64</div><div class="line">multiplexing_api:epoll</div><div class="line">gcc_version:4.4.5</div><div class="line">process_id:13003</div><div class="line">run_id:9b8b398fc63a26d160bf58df90cf437acce1d364</div><div class="line">uptime_in_seconds:2652</div><div class="line">uptime_in_days:0</div><div class="line">lru_clock:654284</div><div class="line">used_cpu_sys:30.01</div><div class="line">used_cpu_user:2.12</div><div class="line">used_cpu_sys_children:1.76</div><div class="line">used_cpu_user_children:1.42</div><div class="line">connected_clients:2</div><div class="line">connected_slaves:0</div><div class="line">client_longest_output_list:0</div><div class="line">client_biggest_input_buf:0</div><div class="line">blocked_clients:0</div><div class="line">used_memory:33056288</div><div class="line">used_memory_human:31.52M</div><div class="line">used_memory_rss:34766848</div><div class="line">used_memory_peak:33064400</div><div class="line">used_memory_peak_human:31.53M</div><div class="line">mem_fragmentation_ratio:1.05</div><div class="line">mem_allocator:jemalloc-3.0.0</div><div class="line">loading:0</div><div class="line">aof_enabled:1</div><div class="line">changes_since_last_save:0</div><div class="line">bgsave_in_progress:0</div><div class="line">last_save_time:1348719252</div><div class="line">bgrewriteaof_in_progress:1</div><div class="line">total_connections_received:6</div><div class="line">total_commands_processed:250313</div><div class="line">expired_keys:0</div><div class="line">evicted_keys:0</div><div class="line">keyspace_hits:0</div><div class="line">keyspace_misses:0</div><div class="line">pubsub_channels:0</div><div class="line">pubsub_patterns:0</div><div class="line">latest_fork_usec:12217</div><div class="line">vm_enabled:0</div><div class="line">role:slave</div><div class="line">aof_current_size:17908619</div><div class="line">aof_base_size:16787337</div><div class="line">aof_pending_rewrite:0</div><div class="line">aof_buffer_length:0</div><div class="line">aof_pending_bio_fsync:0</div><div class="line">master_host:10.6.1.143</div><div class="line">master_port:6379</div><div class="line">master_link_status:up</div><div class="line">master_last_io_seconds_ago:0</div><div class="line">master_sync_in_progress:0</div><div class="line">slave_priority:100</div><div class="line">db1:keys=250000,expires=0</div></pre></td></tr></table></figure>
<p>master_link_status显示为up，同步状态正常。</p>
<p>在此次恢复的过程中，我们同时复制了AOF与RDB文件，那么到底是哪一个文件完成了数据的恢复呢？<br>实际上，当Redis服务器挂掉时，重启时将按照以下优先级恢复数据到内存：</p>
<ol>
<li>如果只配置AOF,重启时加载AOF文件恢复数据；</li>
<li>如果同时 配置了RDB和AOF,启动是只加载AOF文件恢复数据;</li>
<li>如果只配置RDB,启动是将加载dump文件恢复数据。</li>
</ol>
<p>也就是说，AOF的优先级要高于RDB，这也很好理解，因为AOF本身对数据的完整性保障要高于RDB。</p>
<p>在此次的案例中，我们通过在Slave上启用了AOF与RDB来保障了数据，并恢复了Master。</p>
<p>但在我们目前的线上环境中，由于数据都设置有过期时间，采用AOF的方式会不太实用，过于频繁的写操作会使AOF文件增长到异常的庞大，大大超过了我们实际的数据量，这也会导致在进行数据恢复时耗用大量的时间。<br>因此，可以在Slave上仅开启Snapshot来进行本地化，同时可以考虑将save中的频率调高一些或者调用一个计划任务来进行定期bgsave的快照存储，来尽可能的保障本地化数据的完整性。<br>在这样的架构下，如果仅仅是Master挂掉，Slave完整，数据恢复可达到100%。<br>如果Master与Slave同时挂掉的话，数据的恢复也可以达到一个可接受的程度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sukora.cn/testsec/index.html" data-id="cj8h8ybsq0000533821uex7fl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 vv81p2<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>